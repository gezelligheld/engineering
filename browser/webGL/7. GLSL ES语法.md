GLSL ES 在 OpenGL 着色器语言（GLSL）的基础上删除和简化了一部分功能，属于 GPU 层面的编程语言，支持图形相关的操作，支持向量、矩阵等数学运算

#### 特点

- 着色器程序必须有一个 main 函数，不接受任何参数，且没有返回值

##### 数据值类型

支持两种数据值类型

- 数值：包括整数（用 int 声明）和浮点数（用 float 声明）
- 布尔：包括 true 和 false，用 bool 声明

##### 变量命名

GLSL 的变量命名方式和 C 语言基本一致，有一些特殊的规则

- 不能以 gl\_、webgl\_、_webgl_ 作为前缀
- GLSL 的一些保留名称也不能作为变量名称，比如 attribute、uniform、varying 等

#### 向量

##### 向量类型

用来储存包含多个分量的数据，比如颜色信息、齐次坐标、法向量等，向量按照维度分为 2 维、3 维、4 维，按照存储的数据类型分为浮点向量 vec{n}，整型向量 ivec{n}，布尔向量 bvec{n}

- 浮点向量

包括 vec2、vec3、vec4，存储了对应数目个浮点数，浮点向量的赋值相对浮点数宽松一些，会自动对元素做类型转换

```c
vec2 texcoords = vec2(1.0, 1.0);
vec2 texcoords = vec2(1, 1);
```

- 整型向量

包括 ivec2、ivec3、ivec4，存储了对应数目个整数

- 布尔向量

包括 bvec2、bvec3、bvec4，存储了对应数目个布尔数

##### 向量运算

每个向量我们都可以用 {s、t、p、q},{r、g、b、a},{x、y、z、w}来表示。获取各个位置的元素，我们可以使用.操作符

```c
// 第一个元素：v.s、v.r、v.x或v[0]
// 第二个元素：v.t、v.g、v.y或v[1]
vec4 v = vec(1, 2, 3, 4);
```

向低维向量赋值

```c
vec4 v = vec4(1, 2, 3, 4);

// xyzw 方式赋值
vec2 v1 = v.xy;
vec2 v1 = v.xx;
// stpq 赋值
vec2 v1 = v.st;
// rgba 赋值
vec2 v1 = v.rg;

// 构造函数式
vec2 v1 = vec2(v.x, v.y);
vec2 v1 = vec2(v.s, v.t);
vec2 v1 = vec2(v.r, v.g);
```

向量和基础数字类型的运算，将数字和向量的各个分量进行运算

```c
// 加法
vec4 v1 = v + f = (x + f, y + f, z + f, w + f);
// 减法
vec4 v1 = v - f = (x - f, y - f, z - f, w - f);
// 乘法
vec4 v1 = v * f = (x * f, y * f, z * f, w * f);
// 除法
vec4 v1 = v / f = (x / f, y / f, z / f, w / f);
```

两个相同维度的向量可以进行运算，将对应位置的分量进行运算

```c
// 向量 v1 (x1, y1, z1, w1)和向量 v2（x2, y2, z2, w2）
// 加法
vec4 v3 = v1 + v2 = (x1 + x2, y1 + y2, z1 + z2, w1 + w2);
// 减法
vec4 v3 = v1 - v2 = (x1 - x2, y1 - y2, z1 - z2, w1 - w2);

// 乘法
vec4 v3 = v1 * v2 = (v1 * v2, y1 * y2, z1 * z2, w1 * w2);
// 减法
vec4 v3 = v1 / v2 = (x1 / x2, y1 / y2, z1 / z2, w1 / w2);
```

#### 矩阵

##### 矩阵类型

矩阵按照维度分为二阶、三阶、四阶，其中三阶和四阶矩阵用的较多，以四阶矩阵为例

```c
mat4 m = mat4(
    1, 2, 3, 4,  //第一列
    5, 6, 7, 8,  //第二列
    9, 10, 11, 12, //第三列
    13, 14, 15,16 // 第四列
);

// 1个浮点数构造对角线矩阵
mat4 a = mat4(1.0); // [      1.0, 0, 0, 0,    0, 1.0, 0, 0,    0, 0, 1.0, 0,    0, 0, 0, 1.0]

// 利用列向量构造
//第一列
vec4 c0 = vec4(1, 2, 3, 4);
//第二列
vec4 c1 = vec4(5, 6, 7, 8);
//第三列
vec4 c2 = vec4(1, 2, 3, 4);
//第四列
vec4 c3 = vec4(5, 6, 7, 8);
mat4 m = mat4(c0, c1, c2, c4);

// 向量与浮点数混合构造
vec4 c0 = vec4(1, 2, 3, 4);
vec4 c1 = vec4(5, 6, 7, 8);
vec4 c2 = vec4(1, 2, 3, 4);
mat4 m = mat4(c0, c1, c2, 5, 6, 7, 8);
```

##### 矩阵运算

用的最多的就是乘法运算了，矩阵和向量相乘时，要置在乘号左侧

```c
mat4 m = mat4(1.0);
// 乘法
vec4 v1 = m * vec4(1, 2, 3, 4);
// 转置
mat4 m1 = transpose(m0);
// 求逆
mat4 m2 = inverse(m0)
```

#### 内置变量和函数

部分如下

- 顶点着色器相关变量

  - gl_Position：顶点坐标。
  - gl_PointSize：点的尺寸。
  - gl_Normal：顶点法线。

- 片元着色器相关变量

  - gl_FragColor，当前片元的颜色，类型 vec4
  - gl_FragCoord，屏幕像素的 x，y，z，1 / w。
  - gl_FragDepth，片元的最终深度值，在后面的深度测试用到，在片元着色器中我们无法修改 x, y 值，但是可以修改 z 值

- 向量函数

  - cross：叉积
  - dot：点积
  - normalize：归一化向量，返回一个和原向量方向相同、长度为 1 的向量
  - length：向量长度
  - distance：向量距离

#### 存储限定符

- attribute

attribute 变量只能定义在顶点着色器中，它的作用是接收 JavaScript 程序传递过来的与顶点有关的数据，如顶点颜色、法线、坐标等

在 js 中可以通过以下方式获取

```js
/*
program: 着色器程序对象
name: attribute变量名
*/
var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
```

通过以下方式赋值

```js
gl.vertexAttrib1f(a_Position, v0);
gl.vertexAttrib2f(a_Position, v0, v1);
gl.vertexAttrib3f(a_Position, v0, v1, v2);
gl.vertexAttrib4f(a_Position, v0, v1, v2, v3);
```

- uniform

uniform 用来修饰全局变量，它既可以在顶点着色器中定义，也可以在片元着色器中定义，用来接收与顶点无关的数据

在 js 中可以通过以下方式获取

```js
var u_Color = gl.getUniformLocation(gl.program, 'u_Color');
```

通过以下方式赋值

```js
gl.uniform1f(u_Color, v0);
gl.uniform2f(u_Color, v0, v1);
gl.uniform3f(u_Color, v0, v1, v2);
gl.uniform4f(u_Color, v0, v1, v2, v3);
```

- varying

varying 变量一般是成对定义的，即在顶点着色器中定义，在片元着色器中使用。它所修饰的变量在传递给片元着色器之前会进行插值化处理

参考

1. [中级进阶 --- 深入理解 GLSL 语法](https://juejin.cn/book/6844733755580481543/section/6844733755932803086)

#### 进程和线程

- 进程，cpu 资源分配的最小单位，系统会给它分配内存，不同进程之间也可以通信，不过代价较大
- 线程，cpu 调度的最小单位，是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程

#### 浏览器中的进程

浏览器是多进程的，常见进程如下

- Browser 进程：浏览器主进程，负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上；网络资源的管理，下载等

- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

- GPU 进程：最多一个，用于 3D 绘制等

- 渲染进程，默认每个 Tab 页面一个进程，负责页面渲染，脚本执行，事件处理等

相比于单进程，多进程有以下优点

- 避免单个页面崩溃影响整个浏览器
- 避免单个插件崩溃影响整个浏览器
- ...

#### 渲染进程

浏览器的渲染进程是多线程的，常见的线程如下

- GUI 渲染线程

  - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
  - 页面重绘或者重排时该线程就会执行

- JS 引擎线程

  - 负责处理 Javascript 脚本程序
  - 一个渲染进程中只有一个 JS 引擎线程

- 事件触发线程

  - 用来控制事件循环
  - 当 JS 引擎执行代码块如 setTimeOut、鼠标点击、AJAX 异步请求等时，会将对应任务添加到事件线程中
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理

- 定时触发器线程

  - setInterval 与 setTimeout 所在线程，所以浏览器定时计数器并不是由 JavaScript 引擎计数的，因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确
  - 计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行

- 异步 http 请求线程

  - XMLHttpRequest 连接后通过浏览器新开一个线程请求
  - 如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行

##### Browser 进程和渲染进程的通信过程

流程如下

1. Browser 进程收到用户请求，首先需要获取页面内容，随后将该任务传递给渲染进程

2. 渲染进程接收到消息后，交给 GUI 渲染线程，然后开始渲染

   1. 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染，可能会有 JS 线程操作 DOM

   2. 最后渲染进程将结果传递给 Browser 进程

3. Browser 进程接收到结果并将结果绘制出来

##### GUI 渲染线程与 JS 引擎线程互斥

由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面，那么渲染线程前后获得的元素数据就可能不一致了，因此为了防止渲染出现不可预期的结果

当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致卡顿

##### WebWorker 线程

Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法，线程可以执行任务而不干扰用户界面。一个 worker 是使用一个构造函数创建的一个对象运行一个命名的 JavaScript 文件，这个文件包含将在工作线程中运行的代码。worker 运行在另一个不同于 window 的全局上下文中

简言之

- 创建 Worker 时，JS 引擎向浏览器申请开一个子线程
- JS 引擎线程与 worker 线程间可以通过特定的方式通信

WebWorker 和 SharedWorker 区别如下

- WebWorker 只属于某个页面，不会和其他页面的渲染进程共享，所以每个渲染进程都会创建一个新的线程来运行 web worker 中的 js 代码
- SharedWorker 是浏览器所有页面共享的，可以为多个渲染进程共享使用，所以浏览器会单独为 SharedWorker 创建一个进程来执行 SharedWorker 中的 js 代码

> 有且只有一个 SharedWorker 进程，不管创建多少次

参考文档

1. [从浏览器的多进程到 js 的单进程](https://segmentfault.com/a/1190000012925872)

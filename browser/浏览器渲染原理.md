#### 渲染流程

大致流程如下

1. 解析 html 建立 dom 树
2. 解析 css 构建 render 树
3. 布局 render 树，负责各元素尺寸、位置的计算
4. 绘制 render 树，绘制页面像素信息
5. 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成，最后显示到屏幕上

##### 构建 DOM 树

首先浏览器渲染进程的主线程将 html 解析为 DOM 树，其解析算法分为两个阶段

1. 标记化，将 HTML 文本转为 HTML 标记
2. 建树，首先会创建一个 document 对象，根据标记化的结果创建对应 DOM 对象，并将其添加到 DOM 树中。创建一个开放标记栈，接收到标记化的标签时入栈，接收到结束标记时出栈

以下面的 HTML 代码为例

```html
<html>
  <body>
    Hello
  </body>
</html>
```

1. 首先进行标记化，遇到<状态为标记打开，接收[a-z]的字符，当遇到闭合标签的/时会创建一个 end tag 的 token，会进入标记名称状态，直到遇到>表示标记名称记录完成，进入数据状态。当解析到 body 标签时，处于数据状态的时候会接收后面的 Hello 字符。

2. 建树时接收到标记化的 html 标签时，变为 before html 状态，同时创建一个 HTMLHtmlElement 的 DOM 元素, 将其加到 document 根对象上，并进行压栈操作。然后自动变为 before head，如果没有 head 会自动创建一个 HTMLHeadElement 元素加入到 DOM 树中。接收到标记化的 body 标签时，创建 HTMLBodyElement 插入到 DOM 树中，接着状态变成 in body，接收到字符时创建 Text 节点插入 body 元素中。当接收到 body 结束标记时进入 after body 状态，接收到 html 结束标记时进入 after html 状态

此外 HTML5 规范还有一些容错机制，例如 table 元素嵌套会自动拆分为两个 table、form 元素嵌套会忽略里面的 form 等

##### 样式计算

进行样式计算，具体过程如下

1. 格式化样式表，将 CSS 文本转为 styleSheets 对象，其中会标明 CSS 来源，包括 link 标签引入、style 标签中的样式、元素 style 属性
2. 标准化样式属性，某些 CSS 样式的数值并不容易被渲染引擎所理解，需要转换一下，如 em -> px、red -> #ff0000
3. 依据继承和层叠规则计算节点样式，继承规则指每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式；层叠规则指样式作用的优先级，不同选择器权重不同

##### 布局阶段

遍历 DOM 树节点创建布局树（layout tree），将其添加到布局树中，对于 head 标签和 display: none 的元素会被忽略，然后计算每个节点的坐标位置

##### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（Layer tree），这些图层也称为合成层

渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。通常情况下，节点的图层会默认属于父亲节点的图层，触发以下情况会将其提升为一个单独的图层

###### 显式合成

- 拥有层叠上下文属性的元素会被提升为单独的一层

  - HTML 根元素本身就具有层叠上下文。
  - 普通元素设置 position 不为 static 并且设置了 z-index 属性，会产生层叠上下文。
  - 元素的 opacity 值不是 1
  - 元素的 transform 值不是 none
  - 元素的 filter 值不是 none
  - 元素的 isolation 值是 isolate
  - will-change 指定的属性值为上面任意一个

- 需要剪裁的地方也会被创建为图层

如果把 div 的大小限定为 200 _ 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 _ 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层

###### 隐式合成

层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层

这样存在风险，当一个 z-index 比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，从而增加内存压力，甚至页面崩溃，这就是层爆炸，应当避免其他元素与合成层元素重叠

##### 图层绘制

layer tree 构建完成后，渲染引擎将每个图层拆分成一个个绘制指令，再将这些指令按顺序组成待绘制列表

![image](https://pic1.zhimg.com/80/v2-f618a42e7fcf7e565513376f099aa640_1440w.jpg)

至此，上述操作均在渲染进程的 GUI 渲染线程中完成

##### 生成图块和位图

当图层的绘制列表准备好之后，开始绘制操作，渲染进程主线程会把绘制列表提交给合成线程，合成线程会将图层划分为图块（tile），按照视口（viewport）附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图

图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的

![image](https://pic4.zhimg.com/80/v2-ef4066203badce5e880732234ec4a8cf_1440w.jpg)

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中，这就涉及到与 GPU 进程的跨进程操作

![image](https://pic1.zhimg.com/80/v2-87d0635f049e8a572932607baa45e640_1440w.jpg)

##### 显示

当所有图块被栅格化后，合成线程生成一个绘制图块的命令发送给浏览器主进程，然后生成页面

#### 重排、重绘、合成

1. 重排

修改元素的几何属性、移动元素、增删元素等会触发重排，会触发 style（计算样式）后的所有流程，开销大

![image](https://pic1.zhimg.com/80/v2-88eb76703f5765c5889e44140ec549b8_1440w.jpg)

2. 重绘

修改元素的绘制属性会触发重绘，会跳过 layout 和 layer 阶段，性能好于重排

![image](https://pic2.zhimg.com/80/v2-146e92c0b2d807fe77f9e121deda4691_1440w.jpg)

3. 合成

使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作，性能最好

![image](https://pic1.zhimg.com/80/v2-62f789340c5d1882aff5f6e2e930bb58_1440w.jpg)

参考文档

1. [浏览器渲染流程](https://zhuanlan.zhihu.com/p/162722524)

#### q&a

##### load 事件与 DOMContentLoaded 事件的先后

DOMContentLoaded 是仅当 DOM 加载完成，而 load 是当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都加载完成才触发，故 DOMContentLoaded 在先

##### 加载 css

css 加载不会阻塞 DOM 树解析，但会阻塞 render 树渲染。如果 css 加载不阻塞 render 树渲染的话，那么当 render 树渲染完成后，又加载了一部分 css，就会导致额外的重绘和重排

##### 普通图层和复合图层

浏览器渲染的图层一般包含两大类

- 普通图层

普通文档流、absolute 布局都属于普通图层。absolute 虽然可以脱离文档流，但仍属于普通图层，如果普通图层的内容过多，absolute 改变过大，造成的资源损耗是比较严重的

- 复合图层

可以通过硬件加速的方式，声明一个复合图层，GPU 中各个复合图层是单独绘制的，所以互不影响

使用复合图层可以独立于普通图层，可以跳过重排和重绘阶段，复合图层过多会消耗资源。一般采用以下方式可以硬件加速，变为复合图层

- translate3d、translateZ

- opacity 属性/过渡动画（动画执行的过程中才会创建复合图层）

- will-chang 属性

使用硬件加速时，尽可能的使用 index，防止浏览器默认给后续的元素创建复合层渲染，也就是说如果 a 是一个复合图层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，造成不必要的资源损耗

参考

1. [浏览器灵魂之问](https://juejin.cn/post/6844904021308735502)
2. [渲染层合并](https://segmentfault.com/a/1190000014520786)

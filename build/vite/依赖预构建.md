依赖预构建做了两件事，依靠 Esbuild 完成

- 将其他格式转换为 esm 格式。Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能够正常运行，但很多第三方库并没有 es 版本的产物，无法直接运行

- 打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量。每个 import 都会触发一次新的文件请求，在依赖层级深、涉及模块数量多的情况下，会触发成百上千个网络请求

#### 开启预构建

第一次启动项目时会自动开启，其产物存放在 node_modules/.vite 目录，并且会开启强缓存，如果以下几点不变更将一直使用缓存

- package.json 的 dependencies 字段
- 各种包管理器的 lock 文件
- optimizeDeps 配置内容

也可以手动清除缓存，有以下几种方式

- 删除 node_modules/.vite 目录
- 设置 optimizeDeps.force 设为 true
- 命令行执行 npx vite --force 或者 npx vite optimize。Vite 项目的启动可以分为依赖预构建和启动 Dev Server，这里相当于重新执行了一次依赖预构建

#### 定制预构建

相关配置都在 optimizeDeps 下

##### entries

定义预构建入口文件。默认将 HTML 文件作为应用入口，然后根据入口文件扫描出项目中用到的第三方依赖，最后对这些依赖逐个进行编译

##### include

强制预构建的依赖项，尽管 Vite 会自动搜集依赖，但并不完全可靠

- 动态 import 导入，由于 Vite 天然按需加载的特性，经常会导致某些依赖只能在运行时被识别出来，但 Vite 运行时如果发现了新的依赖，随之重新进行依赖预构建，并刷新页面，称为二次构建。二次构建会把预构建流程重新走一遍，而且还会刷新页面，这时候就需要配置 include

- 当配置了 exclude 排除了某个依赖后，假设这个依赖的依赖并没有 es 产物，就会导致运行出错，就可以配置 include

```js
{
  optimizeDeps: {
    include: [
      // 间接依赖的声明语法，通过`>`分开, 如`a > b`表示 a 中依赖的 b
      '@loadable/component > hoist-non-react-statics',
    ];
  }
}
```

#### 原理

1. 首先是预构建缓存的判断，Vite 在每次预构建之后都将一些关键信息写入到了\_metadata.json 文件中，第二次启动项目时会通过这个文件中的 hash 值来进行缓存的判断，如果命中缓存则不会进行后续的预构建流程

2. 如果没有命中缓存，就进行依赖扫描，收集第三方依赖列表

3. 进行依赖打包，扁平化产物文件结构，并且识别不同规范的模块重新导出，并将构建信息保存在\_metadata.json 文件中

#### Vite 3.0 在依赖预构建方面的优化

vite2.9 之前的版本启动服务时，经历了依赖扫描、依赖预构建、启动 Dev Server 的过程，存在两个问题

- 依赖预构建会阻塞 Dev Server 启动
- 当某些 Vite 插件手动注入了 import 语句，会导致 Vite 的二次预构建，需要将所有的依赖全量预构建，页面重新 reload

相应的做了以下优化

- vite2.9 将依赖预构建放在后台执行，不再阻塞 Dev Server 启动
- vite3.0 从根本上解决了二次预构建的问题，把预构建的行为延迟到页面加载的最后阶段进行，此时 Vite 已经编译完了所有的源文件，可以准确地记录下所有需要预构建的依赖，然后统一进行预构建

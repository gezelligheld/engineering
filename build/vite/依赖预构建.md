依赖预构建做了两件事，依靠 Esbuild 完成

- 将其他格式转换为 esm 格式。Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能够正常运行，但很多第三方库并没有 es 版本的产物，无法直接运行

- 打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量。每个 import 都会触发一次新的文件请求，在依赖层级深、涉及模块数量多的情况下，会触发成百上千个网络请求

#### 开启预构建

第一次启动项目时会自动开启，其产物存放在 node_modules/.vite 目录，并且会开启强缓存，如果以下几点不变更将一直使用缓存

- package.json 的 dependencies 字段
- 各种包管理器的 lock 文件
- optimizeDeps 配置内容

也可以手动清除缓存，有以下几种方式

- 删除 node_modules/.vite 目录
- 设置 optimizeDeps.force 设为 true
- 命令行执行 npx vite --force 或者 npx vite optimize。Vite 项目的启动可以分为依赖预构建和启动 Dev Server，这里相当于重新执行了一次依赖预构建

#### 定制预构建

相关配置都在 optimizeDeps 下

##### entries

定义预构建入口文件。默认将 HTML 文件作为应用入口，然后根据入口文件扫描出项目中用到的第三方依赖，最后对这些依赖逐个进行编译

##### include

强制预构建的依赖项，尽管 Vite 会自动搜集依赖，但并不完全可靠

- 动态 import 导入，由于 Vite 天然按需加载的特性，经常会导致某些依赖只能在运行时被识别出来，但 Vite 运行时如果发现了新的依赖，随之重新进行依赖预构建，并刷新页面，称为二次构建。二次构建会把预构建流程重新走一遍，而且还会刷新页面，这时候就需要配置 include

- 当配置了 exclude 排除了某个依赖后，假设这个依赖的依赖并没有 es 产物，就会导致运行出错，就可以配置 include

```js
{
  optimizeDeps: {
    include: [
      // 间接依赖的声明语法，通过`>`分开, 如`a > b`表示 a 中依赖的 b
      '@loadable/component > hoist-non-react-statics',
    ];
  }
}
```

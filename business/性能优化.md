下面从几个角度来聊一下前端性能优化

#### 网络层面

从输入 url 到显示页面的过程中，涉及到网络相关的主要有 DNS 解析、TCP 连接、HTTP 请求/响应

##### DNS 预解析

通过 dns-prefetch 技术将 DNS 解析过程提前，降低 DNS 解析的延迟时间

```html
<link rel="dns-prefetch" href="https://fonts.googleapis.com/" />
```

preconnect 用来建立与服务器的连接，建立 TCP 通道及进行 TLS 握手，进一步降低请求延迟，一般需要加上跨域标识 crorssorigin

```html
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
```

##### HTTP 请求

对于 DNS 解析和 TCP 连接，前端能做的优化非常有限，http 的请求和响应才是前端优化的重点，主要又分为以下两点

- 减少请求次数

  - 只请求当前需要的资源，例如异步的路由加载、图片懒加载、polyfill 动态加载等。用于 polyfill 的包一般比较大，可以通过以下的 cdn 去根据当前浏览器版本动态引入 polyfill
  - 单独的 chunk 不宜过小，小于 10kb 的 chunk 尽量合并，也不能过大，否则单次请求会很耗时

- 减少单次请求所花费的时间

  - 减小资源体积：构建工具一般内置了对 js、css 的压缩处理，基于 esm 的 tree-shaking 有效的减小了产出体积

  - 开启 gzip 压缩：gzip 是 http 压缩的一种方式，使用后 http 数据被服务端压缩然后发送给客户端，客户端在进行相应的解压，一般会减小响应 70%左右的大小，request header 中添加 accept-encoding:gzip 就可以开启。Gzip 压缩是服务器的工作，开启 gzip 压缩后会启动自己的 cpu 去完成这个任务，会损耗服务器的性能。Webpack 中 Gzip 压缩操作的存在，事实上就是为了在构建过程中去做一部分服务器的工作，为服务器分压

  - 图片：兼顾体积，选取合适的图片格式和分辨率

  - 尽量控制 cookie 大小：每次请求会携带同域名下的所有 cookie

  - cdn：内容分发网络指的是一组分布在各个地区的服务器，cdn 预热是指将原站的内容分发到各个地区的 cdn 节点上，cdn 刷新指当原站内容更新时强制去拉取最新的内容。如果没有进行 cdn 预热，大流量的请求会直接到原站服务器上，可能会导致崩溃。cdn 域名和业务域名是不同的，是为了防止请求 cdn 资源时携带与业务域名同源的 cookie

#### 浏览器层面

##### 浏览器缓存

缓存可以减少网络 IO 消耗，提高访问速度，主要包括内存缓存和 http 缓存，http 缓存主要分为强缓存和协商缓存，强缓存优先级更高

##### 预渲染

- 服务端渲染(SSR)：服务端生成好完整的 HTML 内容，直接返回给浏览器，浏览器能够根据 HTML 渲染出完整的首屏内容，而不需要依赖 JS 的加载，从而降低浏览器的渲染压力，节省浏览器请求数据的时间，有利于 seo 优化

- 静态站点生成(SSG)：在构建阶段生成完整的 HTML 内容，然后给浏览器完整的 HTML 内容，不需要依赖 JS 的加载。相比 SSR，SSG 的内容往往动态性不够，适合比较静态的站点，比如文档、博客等场景

##### 预加载

对于一些比较重要的资源可以使用 Preload 进行预加载，即在资源使用之前就进行加载

```html
<link rel="preload" href="style.css" as="style" />
<link rel="preload" href="main.js" as="script" />
```

对于原生 ESM 模块，浏览器提供了 modulepreload 来进行预加载

```html
<link rel="modulepreload" href="/src/app.js" />
```

Prefetch 会告诉浏览器空闲的时候去预加载其它页面的资源，相比于 Preload 兼容性较差

```html
<link rel="prefetch" href="https://B.com/index.js" as="script" />
```

#### rem方案

rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小

```css
/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/
html {font-size: 2rem}

/* 作用于非根元素，相对于根元素字体大小，所以为64px */
p {font-size: 2rem}
```

rem布局本质上就是以html的fonts-size为基准进行等比例变化，而html的fonts-size通常需要结合设计稿宽度和屏幕宽度计算得出，这样可以兼容大部分的页面尺寸兼容，出入比较大的再使用媒体查询做特殊处理

示例如下，假设750px的设计稿和375px的屏幕宽度，设计稿上100px长的元素，可写作2rem

```js
function AutoResponse(designWidth = 750) {
    const target = document.documentElement;
    if (target.clientWidth >= 600) {
        target.style.fontSize = "80px";
    } else {
        target.style.fontSize = target.clientWidth / designWidth * 100 + "px";
    }
}
AutoResponse();
window.addEventListener("resize", () => AutoResponse());
```

也可以根据屏幕宽度和设计稿宽度的比例动态声明font-size，和上面的例子效果一样

```css
html {
    font-size: calc(100vw / 7.5);
}
```

还可以直接设置屏幕宽度为10rem，但是由px换算为rem时麻烦了些

```js
function autoRootFontSize() {
    const homeWrapper = document.getElementById('root');
    document.documentElement.style.fontSize = Math.min(homeWrapper.getBoundingClientRect().width, 600) / 10 + 'px';
}
```

> em：em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小

```css
<div class="p1">
	<div class="s1">1</div>
  	<div class="s2">1</div>
</div>

.p1 {font-size: 16px; line-height: 32px;}
.s1 {font-size: 2em;}
.s2 {font-size: 2em; line-height: 2em;}
```

##### postcss-pxtorem

此插件可以将样式中的px自动转为rem,避免了手动转换的麻烦,需要配合postcss-loader一起使用

基于create-react-app,customize-cra的配置如下

```js
// config-overrides.js
const {addPostcssPlugins, override} = require("customize-cra");
module.exports = {
    webpack: override(
        // ...
        addPostcssPlugins([require('postcss-pxtorem')({
            rootValue: 16, // 设计稿尺寸/16，即设计稿的16px转换为1rem
            unitPrecision: 4,
            propList: ['*', '!border'],
            minPixelValue: 2,
            selectorBlackList: ['Toastify', 'html2canvas', '#root'],
            exclude: /node_modules/i
        })]),
        // ...
    )
}
```

#### vw方案

使用vw布局自适应

- vw 视口宽度window.innerWidth的1%

- vh 视口宽度window.innerHeight的1%

- vmin vw和vh的较小值

- vmax vw和vh的较大值

假设屏幕宽度375px，1vw = 3.75px，按此规律转换即可

##### postcss-px-to-viewport

此插件可以将样式中的px自动转为vw,避免了手动转换的麻烦,需要配合postcss-loader一起使用

基于create-react-app,customize-cra的配置如下

```js
// config-overrides.js
const {addPostcssPlugins, override} = require("customize-cra");
module.exports = {
    webpack: override(
        // ...
        addPostcssPlugins([require('postcss-px-to-viewport')({
            unitToConvert: "px", // 要转化的单位
            viewportWidth: 375, // UI设计稿的宽度
            unitPrecision: 6, // 转换后的精度，即小数点位数
            propList: ["*"], // 指定转换的css属性的单位，*代表全部css属性的单位都进行转换
            viewportUnit: "vw", // 指定需要转换成的视窗单位，默认vw
            fontViewportUnit: "vw", // 指定字体需要转换成的视窗单位，默认vw
            selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名
            minPixelValue: 1, // 默认值1，小于或等于1px则不进行转换
            mediaQuery: true, // 是否在媒体查询的css代码中也进行转换，默认false
            replace: true, // 是否转换后直接更换属性值
            exclude: [/node_modules/], // 设置忽略文件，用正则做目录名匹配
            landscape: false // 是否处理横屏情况
        })]),
        // ...
    )
}
```

#### 屏幕过宽问题

为保证内容区域不变形，一般设置宽度小于600px，超出600px的一般为ipad，两边留白即可

```css
#root {
    width: 100%;
    height: 100%;
    overflow: hidden;
    @media screen and (min-width: 600px) {
        width: 600px;
        margin: 0 auto;
        position: relative;
    }
}
```

若以iPad Pro分辨率1024px为移动端和pc端的分界点，可以利用媒体查询，当超出1024px时不使用rem布局，方便一套代码同时兼容移动端和pc端

```css
@media screen and (max-width: 1024px) {
    html {
        font-size: calc(100vw / 7.5);
    }
}
```
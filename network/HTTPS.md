http 明文传输，在传输过程中任何人都有可能从中截获、修改或者伪造请求发送，是不安全的。HTTPS 是 HTTP 协议的一种扩展，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密，也就是 HTTP + SSL(TLS) = HTTPS，其实是在 HTTP 和 TCP 之前多了一个中间层用来加解密

HTTPS 协议其实非常简单，默认端口号 443，应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP

#### TLS 和 SSL

SSL（安全套接字层），在 OSI 七层模型中处于会话层(第 5 层)，当它发展到第三个大版本的时候才被标准化成为 TLS，也就是 TLS1.0 = SSL3.1

#### TLS 1.2 握手过程

![](../assets/TLS1.2.awebp)

1. 浏览器发送随机数 client_random、TLS 版本、加密方法列表，client_random 用于最终生成密钥，加密方法列表示例如下

```less
// TLS握手过程中，使用ECDHE算法生成pre_random，128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，采用SHA256算法标识服务端身份
TLS_ECDHE_WITH_AES_128_GCM_SHA256
```

2. 服务端响应随机数 server_random、server_params，确认 TLS 版本、需要使用的加密套件和数字证书（包含公钥），server_random 用于最终生成密钥

3. 客户端验证服务端传来的证书和签名是否通过，如果验证通过，客户端结合 server_params、client_params 利用 ECDHE 算法计算出 pre_random，并用公钥加密传递给服务端，然后结合 server_params、client_params、pre_random 通过一个伪随机函数计算出最终的密钥

4. 服务端收到 被公钥加密 pre_random 后，使用私钥解密，结合 server_params、client_params、pre_random 用同样的方式生成最终的密钥，双方生成密钥后发送收尾消息，告知对方之后的传输采用加密方法列表中指定的方式加密

##### 加密方式

对称加密是指加密和解密时使用的密钥都是同样的密钥，攻击者可以在传输过程中拿到 server_random、server_params 和加密方法列表，就可以轻松破解

对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。也就是说服务端有公钥、私钥两把钥匙，公钥是公开的，私钥只要服务器自己知道。那么传输的数据只能通过私钥加密，否则浏览器没法解密，攻击者可以在传输过程中拿到公钥，就能破解

实际上 TLS 1.2 握手过程采用了对称加密和非对称加密相结合的方式，非对称加密体现在客户端用公钥加密由 ECDHE 算法生成的 pre_random，然后服务端私钥解密用于生成最终的密钥；对称加密体现在生成密钥后，双方都通过这个密钥对报文进行加密。最终的密钥是很难被人拿到的，因为私钥只存在与服务端，无法解密出 pre_random

#### 数字证书

为了获取这个证书，服务器运营者需要向第三方认证机构 CA 获取授权，颁发数字证书，用于服务器向浏览器证明自己的身份并传递公钥。数字证书是为了让服务器证明自己的身份，如果攻击者 DNS 劫持成自己的服务，造一份自己的公钥和私钥照样可以传输

浏览器拿到证书后验证流程是，读取证书中的明文内容，CA 进行数字证书的签名时会保存一个 Hash 函数，如果 Hash 函数的结果和用公钥解密明文内容的结果一致，则验证通过

#### TLS1.3

TLS1.3 主要做了以下改进

- 提高安全性

从加密套件中去除了 RSA 算法，被 ECDHE 算法彻底取代，原因在于一旦私钥泄漏，利用 RSA 加密方式的时候会能破解所有历史报文，而 ECDHE 算法在每次握手时都会生成临时的密钥对，即使私钥泄漏也不影响历史数据

- 握手流程改进

![](../assets/TLS1.3.awebp)

相比于 TLS1.2 少了一个往返时延，差别在于 client_params 在第一次握手的时候就传递给服务端，此时服务端就可以生成最终的密钥，无需等待客户端验证证书通过，减少了一些等待时间

参考

1. [http 灵魂之问](https://juejin.cn/post/6844904100035821575)
2. [浏览器灵魂之问](https://juejin.cn/post/6844904021308735502)

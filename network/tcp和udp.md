TCP/IP 协议是一类协议的总称，包括 TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等，作用于传输层，本质上是制定了某种规则来封装报文，其中最具代表性的就是 TCP 和 UDP

#### UDP

全称是用户数据协议，与 TCP 协议一样用于处理数据包，有以下特点

- 面向无连接

不需要握手操作就可以发送数据，不会对数据报文进行任何拆分和拼接操作。在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后传递给网络层；在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

- 有单播，多播，广播的功能

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式

- 不可靠性

没有拥塞控制，一直会以恒定的速度发送数据，在网络条件不好的情况下可能会导致丢包，也无法得知对方是否成功接收到数据了

- 头部开销小，传输报文效率高

UDP 头部包含了以下几个数据：两个十六位的端口号（分别为源端口（可选字段）和目标端口）、整个数据报文的长度、整个数据报文的检验和（IPv4 可选 字段。用于发现头部信息和数据中的错误）。大小只有 8 字节，而 TCP 至少 20 字节

#### TCP

全称是传输控制协议，有以下特点

- 面向连接

发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，保证了可靠性

- 仅支持单播传输

只能进行点对点的数据传输，不支持多播和广播传输方式

- 面向字节流

TCP 为了维护状态，将一个个 IP 包变成了字节流

- 可靠性

TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据将会被重传

- 提供拥塞控制

当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞

- 提供全双工通信

允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据

#### TCP 和 UDP 的区别

| 指标         | UDP                                        | TCP                                  |
| ------------ | ------------------------------------------ | ------------------------------------ |
| 是否连接     | 无连接                                     | 面向连接                             |
| 是否可靠     | 不可靠，无需握手，无拥塞控制               | 可靠，需握手，有拥塞控制             |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多         | 一对一                               |
| 传输方式     | 面向报文                                   | 面向字节流                           |
| 首部开销     | 开销小，仅 8 字节                          | 20-60 字节                           |
| 适用场景     | 适用于实时应用，如 IP 电话、视频会议、直播 | 适用于要求可靠传输的应用，如文件传输 |

总结一下主要有以下几点

1. TCP 需要三次握手建立连接，而 UDP 没有建立连接的过程
2. TCP 更为可靠，一方面是有状态，会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达；一方面是可控制，当丢包时会根据具体情况调整自己的行为，控制自己的发送速度或者重发，而 UDP 是无状态的、不可控的
3. UDP 的数据传输是基于数据报文的，而 TCP 为了维护状态以字节流的形式传输。相应的 UDP 传输报文效率更高，适合直播、通话等实时应用的场景，而 TCP 适合文件传输等对可靠性要求较高的场景

#### TCP 报文

![](../assets/TCP%E6%8A%A5%E6%96%87.awebp)

- 源端口、目标端口：源 IP、源端口、目标 IP 和目标端口加起来可以唯一标识一个连接，IP 层处理了 IP，TCP 只记录端口

- 序列号：无符号 32 位整数，用来保证数据包按正确的顺序组装

- 初始序列号（ISN）：握手过程中用 SYN 交换彼此的 ISN。ISN 不是固定值，每 4 ms 加一，溢出则回到 0，为了防止被攻击者预测到强行关闭连接

- 确认号（ACK）：用来告知对方下一个期望接收的序列号，小于 ACK 的所有字节已经全部收到

- 标记位：常见的标记位有 SYN（发送方想建立连接）、ACK（确认）、FIN（发送方想断开连接）、RST（强行断开连接）、PSH（告知对方这些数据包收到后应该马上交给上层的应用，不能缓存）

- 校验和：占用两个字节，如果遇到校验和有差错的报文，TCP 直接丢弃等待重传，防止传输过程中数据包有损坏

#### 三次握手过程

![](../assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.awebp)

1. 客户端主动发起请求，报文携带 SYN=1 和 Seq=X

2. 服务端接收到后表示同意连接，并响应携带 SYN=1、ACK=X+1、Seq=Y 的报文

3. 客户端接收到响应后，再次请求服务端确认连接，报文携带 ACK=Y+1、Seq=Z，服务端接收到后建立 TCP 连接

为什么是三次呢？三次握手可以让客户端和服务端及时的察觉到可能因为网络原因客户端数据发送失败，服务端的端口可以及时关闭，避免造成额外的开销。如果只有两次，无法保证客户端的接收能力。如果超过三次就没有必要了

三次握手过程中可以携带数据么？前两次握手不能携带数据，一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。第三次握手的时候，基本确定了客户端和服务的接收、发送的能力正常，是可以携带数据的

#### 四次挥手过程

![](../assets/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.awebp)

1. 客户端要断开了，报文携带 FIN=1，序列号 Seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时客户端处于半关闭，不能发送报文只能接收

2. 服务端收到后表示确认，发送携带 ACK=1，ack=u+1，序列号 Seq=v 的数据

3. 服务器将最后的数据发送完毕后，服务端关闭客户端的连接，发送携带标志为 FIN=1，ack=u+1，Seq=w 的数据，然后等待客户端确认

4. 客户端表示确认，发送标识位 ACK=1，Seq=u+1，ack=w+1 的数据，完成关闭

客户端在挥手完成正式断开连接前需要等待 2 个报文最大生存时间 MSL，一个用来确保四次挥手中客户端最后的 ACK 报文最终能达到服务端，另一个确保服务端没有收到 ACK 时重传的报文可以到达

为什么是四次呢？因为服务端在接收到 FIN, 往往不会立即返回 FIN, 必须等到服务端所有的报文都发送完毕了，才能发 FIN，因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN，就造成了四次挥手。如果是三次，即服务端将 ACK 和 FIN 一起响应的话，由于需要等服务端将报文发送完毕才能响应 FIN，会有延迟，长时间的延迟会让客户端误以为 FIN 没有发送到服务端，从而不断的重发

#### SYN Flood 攻击

TCP 握手之前，服务端监听了某个端口之后变成 LISTEN 状态，同时创建两个队列

- 半连接队列（SYN 队列）：当客户端发送 SYN 到服务端，服务端收到以后回复 ACK 和 SYN，此时这个连接就被推入了 SYN 队列
- 全连接队列（ACCEPT 队列）：当客户端返回 ACK, 服务端接收后，三次握手完成，这个时候连接等待被具体的应用取走，在被取走之前会被推入 ACCEPT 队列

SYN Flood 属于典型的 DoS/DDoS 攻击，用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送 SYN，对服务端而言会产生两个后果

- 处理大量的 SYN 包并返回对应 ACK，从而占满整个半连接队列，无法处理正常的请求
- 由于是不存在的 IP，服务端长时间收不到客户端的 ACK，会导致服务端不断重发数据

应对措施如下

- 增加半连接队列的容量
- 减少 SYN + ACK 重试次数，避免大量的超时重发
- 利用 SYN Cookie 技术，在服务端接收到 SYN 后不立即分配连接资源，而是根据这个 SYN 计算出一个 Cookie，连同第二次握手回复给客户端，在客户端回复 ACK 的时候带上这个 Cookie 值，服务端验证 Cookie 合法之后才分配连接资源

#### TCP 快速打开

TCP 如果每次建立都需要三次握手效率会比较低，采用 TCP 快速打开（TFO）对非首次的握手过程进行了优化，流程如下

1. 首次三次握手时，客户端发送 SYN 给服务端，服务端根据 SYN 计算一个 SYN cookie 并返回给客户端，客户端缓存下来

2. 再次三次握手时，客户端会将之前缓存的 Cookie、SYN 和 HTTP 请求发给服务端，如果 Cookie 验证通过，那么在服务端响应 SYN + ACK 后就可以发送 http 请求了，提前了一个往返时延

![](../assets/TFO.awebp)

参考

1. [TCP 协议灵魂之问](https://juejin.cn/post/6844904070889603085)

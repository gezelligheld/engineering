#### 双线程架构

普通网页是单线程的，渲染线程和脚本线程互斥，js 脚本执行时间过长会导致页面卡顿，体验较差，而小程序是双线程的，包括渲染层和逻辑层

- 渲染层：使用 WebView 进行渲染，WXML 模板和 WXSS 样式就工作在渲染层
- 逻辑层：采用 JsCore 线程运行 JS 脚本
- Native 层：渲染层和逻辑层的通信、网络请求、离线存储等统一由微信客户端（Native）转发处理

![](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)

#### webview

webview 是移动端原生应用中内置的 webkit 内核浏览器，区别于普通网页是运行在浏览器中的。为了更加接近原生应用 APP 的用户体验，一个小程序含有多个页面，渲染层存在多个 WebView 线程，区别于单页面应用，如果单页面应用要加载新的页面需要先卸载当前页面再重新加载

#### 运行环境

在小程序的开发过程中，主要面对 IOS/Android 的微信客户端、小程序开发者工具等运行环境，在这些不同环境下脚本执行环境、组件渲染环境、性能都有所差异

- 在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 JavaScript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的
- 在 Android 上，小程序逻辑层的 JavaScript 代码运行在 V8 中，视图层是由基于 Mobile Chromium 内核的微信自研 XWeb 引擎来渲染的
- 在 Windows 上，小程序逻辑层 JavaScript 和视图层都是用 Chromium 内核
- 在 开发工具上，小程序逻辑层的 JavaScript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的

差异主要有两方面

- JavaScript 语法和 API 支持不一致，编译成 es5 进行语法方面不一致的规避，小程序基础库内置了 polyfill 来弥补 API 方面的差异，如 Promise 在 IOS 下使用 setTimeout 进行 polyfill，就不会产生微任务
- WXSS 渲染表现不一致

#### 运行机制

小程序的启动分两种

- 冷启动：用户首次打开或小程序销毁后再次打开
- 热启动：已经打开过小程序，并在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态

当用户关闭了小程序后，发生了以下的事情

1. 小程序并未真的关闭，而是进入了后台状态，还可以短暂运行一小段时间
2. 当进入后台状态 5 秒后，微信会停止小程序 JS 线程的执行，小程序进入挂起状态，此时小程序的内存状态会被保留，代码执行会停止，但如音乐播放、地理位置等会持续运行
3. 当挂起 30 分钟后或小程序占用系统资源过高，小程序会被自动销毁

#### 更新机制

更新小程序版本的机制分为两种情况

- 同步更新：微信定期检查发现新版本或用户长时间未使用小程序时，会同步更新，阻塞启动小程序的流程
- 异步更新：小程序每次冷启动时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包，但当前使用的还是旧版本，新版本的小程序需要等下一次冷启动才会使用

开发者也可以手动触发更新

```js
const updateManager = wx.getUpdateManager();

updateManager.onCheckForUpdate(function (res) {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate);
});

updateManager.onUpdateReady(function () {
  wx.showModal({
    title: '更新提示',
    content: '新版本已经准备好，是否重启应用？',
    success(res) {
      if (res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate();
      }
    },
  });
});

updateManager.onUpdateFailed(function () {
  // 新版本下载失败
});
```

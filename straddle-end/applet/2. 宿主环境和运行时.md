#### 双线程架构

普通网页是单线程的，渲染线程和脚本线程互斥，js 脚本执行时间过长会导致页面卡顿，体验较差，而小程序是双线程的，包括渲染层和逻辑层

- 渲染层：使用 WebView 进行渲染，WXML 模板和 WXSS 样式就工作在渲染层
- 逻辑层：采用 JsCore 线程运行 JS 脚本
- Native 层：渲染层和逻辑层的通信、网络请求、离线存储等统一由微信客户端（Native）转发处理

![](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)

需要注意的是，在双线程模型下，任何数据传递都是线程间的通信，都会有一定的延时

#### webview

webview 是移动端原生应用中内置的 webkit 内核浏览器，区别于普通网页是运行在浏览器中的。为了更加接近原生应用 APP 的用户体验，一个小程序含有多个页面，渲染层存在多个 WebView 线程，区别于单页面应用，如果单页面应用要加载新的页面需要先卸载当前页面再重新加载

#### 运行环境

在小程序的开发过程中，主要面对 IOS/Android 的微信客户端、小程序开发者工具等运行环境，在这些不同环境下脚本执行环境、组件渲染环境、性能都有所差异

- 在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 JavaScript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的
- 在 Android 上，小程序逻辑层的 JavaScript 代码运行在 V8 中，视图层是由基于 Mobile Chromium 内核的微信自研 XWeb 引擎来渲染的
- 在 Windows 上，小程序逻辑层 JavaScript 和视图层都是用 Chromium 内核
- 在 开发工具上，小程序逻辑层的 JavaScript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的

差异主要有两方面

- JavaScript 语法和 API 支持不一致，编译成 es5 进行语法方面不一致的规避，小程序基础库内置了 polyfill 来弥补 API 方面的差异，如 Promise 在 IOS 下使用 setTimeout 进行 polyfill，就不会产生微任务
- WXSS 渲染表现不一致

安卓和 iOS 的启动耗时也存在较大的差异，iOS要好于安卓，原因有以下几点

- iOS 小程序和微信共用进程，而 Android 上小程序运行在独立进程，需要额外的进程创建和一些基础模块的初始化流程
- iOS 上需要使用系统提供的 WebView 和 JavaScript Core，初始化开销几乎可以忽略
- 安卓 UI 和系统组件的创建的开销远高于 iOS

#### 运行机制

小程序的启动分两种

- 冷启动：用户首次打开或小程序销毁后再次打开
- 热启动：已经打开过小程序，并在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态

当用户关闭了小程序后，发生了以下的事情

1. 小程序并未真的关闭，而是进入了后台状态，还可以短暂运行一小段时间
2. 当进入后台状态 5 秒后，微信会停止小程序 JS 线程的执行，小程序进入挂起状态，此时小程序的内存状态会被保留，代码执行会停止，但如音乐播放、地理位置等会持续运行
3. 当挂起 30 分钟后或小程序占用系统资源过高，小程序会被自动销毁

#### 启动流程

启动流程是指用户打开小程序到首页渲染完成（ready钩子触发），具体流程如下

1. 资源准备

- 小程序相关信息准备：主要包括小程序头像、版本、权限等信息的获取，首次访问（没有缓存命中）、同步更新小程序版本、强制更新小程序版本会阻塞小程序的启动流程
- 运行环境准备：主要包括小程序进程、系统组件、ui元素、webview容器、js运行环境、小程序基础库等，微信客户端会在启动前做一定程度的预加载
- 代码包准备：下载代码包，通过代码包压缩、增量更新、代码包复用等方式降低了下载时耗。增量更新是指当代码包更新时无需下载完整的代码包，只需下载算法生成的增量包即可；代码包复用是指当代码包更新时，如果代码包的md5没有发生变化就不会重复下载

2. 代码注入

代码包准备就绪后，逻辑层和渲染层的代码注入并行开始

- 逻辑层：从代码包读取小程序配置和代码后，注入js引擎，会触发App.onLaunch 和 App.onShow 生命周期。如果使用了插件或扩展会先注入插件或扩展
- 渲染层：WXSS 和 WXML 会编译成 JavaScript 代码注入到视图层，包含页面渲染需要的页面结构和样式信息

3. 首页渲染

逻辑层代码注入完成后，进行页面组件树初始化，生成初始数据发送到视图层，并依次触发首页的 Page.onLoad, Page.onShow 生命周期

视图层代码注入、并收到逻辑层发送的初始数据后，将初始数据套用在对应的WXML片段上生成节点树，进行小程序首页的渲染，并触发首页的 Page.onReady 事件，至此启动流程结束

> 生命周期启动流程中执行顺序：App.onLaunch -> App.onShow -> Page.onLoad -> Page.onShow -> Page.onReady

#### 状态更新流程

1. 逻辑层虚拟 DOM 树的遍历和更新，触发组件生命周期和 observer 等
2. 将 data 从逻辑层传输到视图层
3. 结合WXML片段得到一个新节点树，将新节点树与当前节点树进行比较，进行节点的更新、添加、移除等操作，然后用新节点树替换旧节点树
4. 更新真实DOM触发页面渲染

#### 页面切换流程

当前页面跳转到未加载的页面时经历了以下过程

1. 触发页面切换：调用路由相关api、tabBar、左上角返回按钮、系统左滑返回等方式跳转页面

2. 如果目标页面在分包中，先加载分包，然后在逻辑层注入js代码

3. 初始化

- 渲染层：创建WebView、注入小程序基础库、注入主包公共代码、注入分包代码（如果在分包中）。为了降低页面切换耗时，小程序会在页面渲染完成后进行预加载供切换页面使用，包括创建WebView、注入小程序基础库、注入主包公共代码
- 逻辑层：触发上一个页面的 onHide/onUnload，更新页面栈并生成初始数据发送到视图层，依次触发目标页面的onLoad和onShow

4. 结合初始数据和渲染层信息，目标页面渲染完成，触发onReady。然后进行页面切换动画，如果页面初始化和渲染超时，会提前推入

> 生命周期页面切换流程中执行顺序：当前页面的 onHide/onUnload -> 目标页面的 onLoad -> 目标页面的 onShow
> 当前页面跳转到已加载的页面时，会跳过初始化和目标页面渲染的过程，此时生命周期执行顺序：当前页面的 onHide/onUnload -> 目标页面的 onShow


#### 版本更新机制

更新小程序版本的机制分为两种情况

- 同步更新：微信定期检查发现新版本或用户长时间未使用小程序时，会同步更新，阻塞启动小程序的流程
- 异步更新：小程序每次冷启动时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包，但当前使用的还是旧版本，新版本的小程序需要等下一次冷启动才会使用

开发者也可以手动触发更新

```js
const updateManager = wx.getUpdateManager();

updateManager.onCheckForUpdate(function (res) {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate);
});

updateManager.onUpdateReady(function () {
  wx.showModal({
    title: '更新提示',
    content: '新版本已经准备好，是否重启应用？',
    success(res) {
      if (res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate();
      }
    },
  });
});

updateManager.onUpdateFailed(function () {
  // 新版本下载失败
});
```

#### 网络

- 小程序只可以跟指定的域名进行网络通信，需要在小程序后台进行配置
- DNS预解析域名也需要在小程序后台进行配置
- 小程序必须使用 HTTPS/WSS 发起网络请求。在微信开发者工具中，可以临时开启 开发环境不校验请求域名、TLS版本及HTTPS证书 选项，跳过服务器域名的校验
- 网络请求默认超时时间和最大超时时间都是 60s，websocket最大并发限制为5个，其他网络请求为10个

#### 存储

小程序有自己的本地存储，同一用户、同一小程序下上限为10MB，不同用户、不同小程序、不同小程序的同一插件、同一小程序的不同插件都是隔离的

#### 文件系统

小程序的文件系统有以下几种文件类型

- 代码包文件：在项目目录中添加的文件
- 本地文件：以用户、appid为维度隔离的文件存储区域
  - 本地临时文件：临时产生，运行时最多存储 4GB，结束运行后，如果已使用超过 2GB，按使用时间清理至少于2GB
  - 本地缓存文件：通过接口把本地临时文件缓存后产生的文件，重启后仍可用
  - 本地用户文件：通过接口把本地临时文件缓存后产生的文件，允许自定义目录和文件名，和本地缓存文件加起来不超过200MB，可写
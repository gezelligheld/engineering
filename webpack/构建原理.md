#### 构建

项目中使用的每个文件都是一个模块（module），通过相互引用，形成图数据结构。在打包过程中，这些模块会被合并成chunk，chunk合并成chunk组

chunk分为两种形式

- initial：入口文件的main chunk，此chunk由入口文件所有所依赖的文件生成

- no-initial：延迟加载的chunk，可能是动态导入或者SplitChunksPlugin产生的

```js
import loadable from 'react-loadable';
import {Spin} from 'antd';

export default [
    {
        path: '/help',
        exact: true,
        component: loadable({
            loader: () =>
                // 动态导入
                import(/* webpackChunkName: 'help' */ /* webpackMode: "lazy" */ '../../modules/help'),
            loading: Spin
        })
    }
];
```

#### Manifest

在webpack构建的应用中，包含3种代码：

- 业务代码
- 依赖的第三方代码
- webpack 的 runtime 和 manifest，管理所有模块的交互

runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。runtime包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及按需加载模块的执行逻辑

index.html 文件、一些 bundle和各种资源加载到浏览器中时，文件结构现在已经不存在，所以webpack利用manifest数据管理所有模块之间的交互。当编译器(compiler)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点，这个数据集合称为manifest

当完成打包并发送到浏览器时，会在运行时通过Manifest来解析和加载模块。无论你选择哪种模块语法，那些 import 或 require 语句现在都已经转换为 __webpack_require__ 方法，此方法指向模块标识符。通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块

#### hash

当企图通过使用浏览器缓存来改善项目的性能时，这一过程尤为重要。通过使用 bundle 计算出内容散列作为文件名称，这样在内容或文件修改时，浏览器中将通过新的内容散列指向新的文件，从而使缓存无效。runtime和manifest的注入在每次构建都会发生变化，这会导致即使表面上某些内容没有修改，计算出的哈希还是会改变

webpack存在以下几种计算hash的方式

- hash

每次构建生成的hash，所有文件都相同

- chunkhash

基于关联的chunk生成，单个文件的改动只会影响与之关联的chunk的hash

- contenthash

基于文件内容生成，文件内容改变会影响hash